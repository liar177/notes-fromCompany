# vue 复建笔记1

## watch和computed的异同**(不要使用箭头函数来定义watcher函数)**

### 计算属性computed：

1.支持缓存，只有依赖数据发生改变，才会重新进行计算

2.不支持异步，当computed内有异步操作时无效，无法监听数据的变化

3.**如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法** 



>  
>
> ==我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 **A**，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 **A**。如果没有缓存，我们将不可避免的多次执行 **A** 的 getter！如果你不希望有缓存，请用方法来替代。==
>
> 



###      侦听属性watch：

​		相比于利用缓存机制减少不必要开销的computed ，watch 显然是一种更为通用和普遍的观察和响应数据		变动的方式。当需要在数据变化时执行 ==异步== 或需要==多次执行侦听操作==时，watch时非常有用的。

​		1. 不支持缓存，数据变，直接会触发相应的操作；

​		2.watch支持异步；

​		3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；

​        4.当一个属性发生变化时，需要执行对应的操作；一对多；

​         5.监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，			函数有两个参数，

　　(1)immediate：组件加载立即触发回调函数执行，

　　(2)deep: 深度监听，为了发现**对象内部值**的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。

## index.html中的#app 和 App.vue中template根元素的#app 有何区别和联系？

基础源文件中index.html 里的 #app 元素只是用于man.js中完成vue实例对象初始化的显式挂载，App.vue中的template的根元素会在渲染后直接覆盖，所以即使两者都是#app (即id=app)也不会有影响 。



## 什么是js中的getter和setter

在搜寻结果时觉得知乎的这个回答挺简洁明了的

> https://www.zhihu.com/question/275575143
>
> Getter/Setter是一个万恶的概念，其实就是一个规定好参数和context的函数标准。
>
> ```text
> let obj = {
>   a:1,
>   b:0
> }
> ```
>
> 
> 取a的值 obj.a 就是getter
> 设置a的值obj.a=10 就是setter
>
> 如果我想统计 a被访问了多少次，把次数统计到b中
>
> ```text
> let obj = {_a:0,b:0}
> Object.defineProperty(obj,'a',{
>   get () {
>     this.b ++ 
>     return this._a
>   },
>   set (a) {
>     this._a = a
>   }
> })
> log(obj.a) // 0
> log(obj) //{"_a": 0, "b": 1}
> obj.a = 100
> log(obj) // {"_a": 100, "b": 1}
> ```
>
> 当调用obj.a实际上执行的是get函数，当调用obj.a=100 实际上执行的是 set函数。这个就是getter和setter

与vue的联系

​	在vue 中提到将属性(应该是指data中定义的属性)转化为getter 和 setter的这样一种说法，有点拗口

>  vue的数据改变需要更新到视图中的，那么Vue是如何知道数据啥时候改变呢？
> 就是通过在属性上加上它自己的setter,正如上面属性a的setter,可以在里面加上通知『我改变』 的逻辑。把属性转化成getter/setter 这里有两个名词，一个是属性，一个是getter/setter,属性可以理解为默认的getter/setter，也就是没有自定义的逻辑在里面，就是单纯的访问和设置,getter/setter是会加上Vue自己的逻辑的。 



## vue中key的作用

> https://www.jianshu.com/p/5d771cf57012

总的来说，key属性可以让vue能唯一确定一个DOM元素，这个作用可以具体表现在以下几个方面：

1.在页面上有一处使用数组数据渲染的地方，想要插入一个数组数据，如果没有为每个数据唯一指定一个key，那么在插入之后没有受到影响的数据不会变化，受到影响的数据会进行依次刷新改变，效率很低；

如果指定了key，便只需要一次创建操作就能实现

==为了实现高效的更新虚拟 DOM，提高性能。其原理是vue在patch的过程中通过key可以精准的判断两个节点是否是同一个，从而避免频繁的更新元素，使得整个patch过程更加高效，减少DOM操作量，提高性能。==

2.在有一些使用数组渲染的地方如果需要删除操作，如果没有指定key，会产生一些bug

3.vue在使用 相同的标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。 

4. 同理，key属性被用在组件上时，当key改变时会引起新组件的创建和原有组件的删除，此时组件的生命周期钩子就会被触发。 

### 在自定义事件名时，可以遵循vue官方的建议——使用kebab-case的事件名

